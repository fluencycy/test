<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        // AR-only version
// - Right trigger: place MANY Pikachus (each becomes selected)
// - Right thumbstick: move the SELECTED Pikachu on XZ plane
// - No desktop fallback
// - Reticle: green & unpickable
// - Robust instancing: clone child meshes to avoid empty clones

var placedList = [];        // all placed instances' roots (TransformNode)
var selectedInst = null;    // current selected root
var FACE_YAW = Math.PI;     // face user
var MOVE_SPEED = 0.6;       // m/s

// Robust "prototype" -> "new instance" creator
function createInstanceFromPrototype(proto, name, scene) {
    var root = new BABYLON.TransformNode(name, scene);
    // 逐个克隆子网格并挂到新 root 下
    proto.getChildMeshes().forEach(function (m, i) {
        var c = m.clone(name + "_m" + i, root);
        c.isVisible = true;
        c.setEnabled(true);
    });
    // 复制缩放/旋转(避免每次再设)
    root.scaling.copyFrom(proto.scaling);
    if (proto.rotationQuaternion) {
        root.rotationQuaternion = proto.rotationQuaternion.clone();
    } else {
        root.rotation.copyFrom(proto.rotation);
    }
    return root;
}

var createScene = function () {
    var scene = new BABYLON.Scene(engine);

    // ----- camera & light
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControl(canvas, true); // harmless in XR

    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    // ----- ground 先创建(方便你在非XR环境里也能看到舞台)
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 6, height: 6 }, scene);

    // ----- load GLB into a HIDDEN prototype hierarchy
    var GLB_URL = "./pikachu.glb";
    var modelProto = null;

    BABYLON.SceneLoader.Append("", GLB_URL, scene, function () {
        // 把场景中除了 ground 的网格都收拢到一个隐藏 root 作为“原型”
        var meshes = scene.meshes.filter(function (m) { return m && m.name !== "ground"; });
        var root = new BABYLON.TransformNode("protoRoot", scene);
        meshes.forEach(function (m) { m.setParent(root); });

        root.scaling.setAll(0.05);
        root.rotation = new BABYLON.Vector3(0, Math.PI, 0);

        // 隐藏:逐个禁用子网格,避免原型本体出现在场景中
        root.getChildMeshes().forEach(function (m) { m.setEnabled(false); m.isVisible = false; });

        modelProto = root;
        // console.log("Prototype ready with", root.getChildMeshes().length, "meshes");
    });

    // ----- WebXR (AR) + Hit Test
    scene.createDefaultXRExperienceAsync({
        uiOptions: { sessionMode: "immersive-ar", referenceSpaceType: "local-floor" },
        optionalFeatures: true
    }).then(function (xr) {

        // 关闭会抢右摇杆的功能:只让我们移动皮卡丘
        var fm = xr.baseExperience.featuresManager;
        try { fm.disableFeature(BABYLON.WebXRFeatureName.MOVEMENT); } catch(e){}
        try { fm.disableFeature(BABYLON.WebXRFeatureName.TELEPORTATION); } catch(e){}
        try { fm.disableFeature(BABYLON.WebXRFeatureName.POINTER_SELECTION); } catch(e){}

        // Hit Test
        var hitTest = fm.enableFeature(BABYLON.WebXRFeatureName.HIT_TEST, "latest",
            { entityTypes: ["plane", "point"] });

        // Reticle
        var reticle = BABYLON.MeshBuilder.CreateTorus("reticle_ar",
            { diameter: 0.15, thickness: 0.003, tessellation: 32 }, scene);
        reticle.rotationQuaternion = new BABYLON.Quaternion();
        reticle.isVisible = false;
        reticle.isPickable = false;
        var retMat = new BABYLON.StandardMaterial("retMat_ar", scene);
        retMat.emissiveColor = new BABYLON.Color3(0.1, 0.9, 0.2);
        retMat.disableLighting = true;
        reticle.material = retMat;

        hitTest.onHitTestResultObservable.add(function (results) {
            if (results && results.length > 0) {
                var hit = results[0];
                hit.transformationMatrix.decompose(reticle.scaling, reticle.rotationQuaternion, reticle.position);
                reticle.isVisible = true;
            } else {
                reticle.isVisible = false;
            }
        });

        // Right controller: trigger to place; thumbstick to move selected model
        xr.input.onControllerAddedObservable.add(function (xrInput) {
            if (xrInput.inputSource.handedness !== "right") return;

            xrInput.onMotionControllerInitObservable.add(function (mc) {
                // Trigger => place new Pikachu
                var trigger = mc.getComponent("xr-standard-trigger");
                if (trigger) {
                    trigger.onButtonStateChangedObservable.add(function () {
                        if (!trigger.pressed) return;
                        if (!reticle.isVisible) return;
                        if (!modelProto) return;

                        // 实例化(保证层级完整)
                        var inst = createInstanceFromPrototype(modelProto, "placed_ar_" + Date.now(), scene);

                        // 放到命中位姿,并让它朝向你
                        inst.position.copyFrom(reticle.position);
                        if (!inst.rotationQuaternion)
                            inst.rotationQuaternion = reticle.rotationQuaternion.clone();
                        else
                            inst.rotationQuaternion.copyFrom(reticle.rotationQuaternion);

                        inst.addRotation(0, FACE_YAW, 0);

                        // 记录/选中
                        placedList.push(inst);
                        selectedInst = inst;
                    });
                }

                // Thumbstick => move selected on XZ plane
                var stick = mc.getComponent("xr-standard-thumbstick");
                if (stick) {
                    var lastTS = performance.now();
                    stick.onAxisValueChangedObservable.add(function (axes) {
                        if (!selectedInst) return;
                        var now = performance.now();
                        var dt = Math.min((now - lastTS) / 1000, 0.05);
                        lastTS = now;

                        selectedInst.position.x += axes.x * MOVE_SPEED * dt;
                        selectedInst.position.z += -axes.y * MOVE_SPEED * dt;
                    });
                }
            });
        });
    }).catch(function (e) {
        console.warn("WebXR not available or failed to init:", e);
    });

    return scene;
};

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
