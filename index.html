<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        // Full drop-in code for Babylon.js:
// - AR mode: WebXR + Hit Test + right trigger to place MANY models
// - AR mode: Right thumbstick moves the currently selected model on the horizontal plane
// - Reticle: clearly visible (green, lighting-independent), and not pickable
// NOTE: Desktop fallback has been REMOVED per request.
// NOTE: XR controller thumbstick is dedicated to MOVING the selected model;
//       camera movement/teleportation features are disabled.

var placedList = [];                 // store all placed instances
var selectedInst = null;             // the instance to move
var FACE_YAW = Math.PI;              // rotate 180° so the model faces you (tweak if needed)
var MOVE_SPEED = 0.6;                // m/s for AR thumbstick

// helper: (kept for consistency; harmless in XR) tag the instance as "placed"
function attachHorizontalDrag(inst, scene) {
    // Keep only the metadata tag; remove desktop drag behavior entirely
    if (!inst.metadata) inst.metadata = {};
    inst.metadata.placed = true;
}

var createScene = function () {
    // ---------- Your original setup ----------
    var scene = new BABYLON.Scene(engine);

    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControl(canvas, true); // harmless in XR; needed if你在PC上看看画面

    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;

    var GLB_URL = "./pikachu.glb";
    var modelProto = null; // prototype holder to clone for placement

    BABYLON.SceneLoader.Append("", GLB_URL, scene, function () {
        // Group everything (except ground) under a hidden root as prototype
        var all = scene.meshes.filter(function (m) { return m.name !== "ground"; });
        var root = new BABYLON.TransformNode("root", scene);
        all.forEach(function (m) { m.setParent(root); });

        root.scaling.setAll(0.05);
        root.rotation = new BABYLON.Vector3(0, Math.PI, 0);
        root.setEnabled(false);        // keep as prototype (hidden)
        modelProto = root;
    });

    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 6, height: 6 }, scene);

    // ---------- WebXR AR + Hit Test + right trigger to place ----------
    scene.createDefaultXRExperienceAsync({
        uiOptions: { sessionMode: "immersive-ar", referenceSpaceType: "local-floor" },
        optionalFeatures: true
    }).then(function (xr) {

        // ✅ 关闭可能占用摇杆的 XR 相机移动/传送等特性(确保摇杆只用于移动皮卡丘)
        var fm = xr.baseExperience.featuresManager;
        try { fm.disableFeature(BABYLON.WebXRFeatureName.MOVEMENT); }     catch(e){}
        try { fm.disableFeature(BABYLON.WebXRFeatureName.TELEPORTATION);} catch(e){}
        // POINTER_SELECTION 在本场景里也不用
        try { fm.disableFeature(BABYLON.WebXRFeatureName.POINTER_SELECTION);} catch(e){}

        // Enable WebXR Hit Test
        var hitTest = fm.enableFeature(
            BABYLON.WebXRFeatureName.HIT_TEST,
            "latest",
            { entityTypes: ["plane", "point"] }
        );

        // AR reticle (torus). It appears when AR hit test succeeds.
        var reticle = BABYLON.MeshBuilder.CreateTorus("reticle_ar",
            { diameter: 0.15, thickness: 0.003, tessellation: 32 }, scene);
        reticle.rotationQuaternion = new BABYLON.Quaternion();
        reticle.isVisible = false;
        reticle.isPickable = false; // do not interfere with picking
        var retMat = new BABYLON.StandardMaterial("retMat_ar", scene);
        retMat.emissiveColor = new BABYLON.Color3(0.1, 0.9, 0.2);
        retMat.disableLighting = true; // clearly green regardless of lights
        reticle.material = retMat;

        hitTest.onHitTestResultObservable.add(function (results) {
            if (results && results.length > 0) {
                var hit = results[0];
                hit.transformationMatrix.decompose(reticle.scaling, reticle.rotationQuaternion, reticle.position);
                reticle.isVisible = true;
            } else {
                reticle.isVisible = false;
            }
        });

        // Right controller: trigger to place; thumbstick to move selected model
        xr.input.onControllerAddedObservable.add(function (xrInput) {
            if (xrInput.inputSource.handedness !== "right") return;

            xrInput.onMotionControllerInitObservable.add(function (mc) {
                // Trigger => place a NEW instance at reticle pose
                var trigger = mc.getComponent("xr-standard-trigger");
                if (trigger) {
                    trigger.onButtonStateChangedObservable.add(function () {
                        if (!trigger.pressed) return;
                        if (!reticle.isVisible) return;
                        if (!modelProto) return;

                        var inst = modelProto.clone("placed_ar_" + Date.now());
                        inst.getChildMeshes().forEach(function (m) { m.isVisible = true; });
                        inst.setEnabled(true);

                        inst.position.copyFrom(reticle.position);
                        inst.rotationQuaternion = reticle.rotationQuaternion.clone();
                        // face the user
                        inst.addRotation(0, FACE_YAW, 0);

                        // mark (no desktop drag now)
                        attachHorizontalDrag(inst, scene);

                        placedList.push(inst);
                        selectedInst = inst; // newest becomes selected
                    });
                }

                // Thumbstick => move the selected model on XZ plane (ONLY this; camera move disabled above)
                var stick = mc.getComponent("xr-standard-thumbstick");
                if (stick) {
                    var lastTS = performance.now();
                    stick.onAxisValueChangedObservable.add(function (axes) {
                        if (!selectedInst) return;
                        var now = performance.now();
                        var dt = Math.min((now - lastTS) / 1000, 0.05); // seconds, clamp max step
                        lastTS = now;

                        // axes.x: right positive; axes.y: up is negative forward => z negative
                        selectedInst.position.x += axes.x * MOVE_SPEED * dt;
                        selectedInst.position.z += -axes.y * MOVE_SPEED * dt;
                    });
                }
            });
        });
    }).catch(function (e) {
        console.warn("WebXR not available or failed to init:", e);
    });


    return scene;
};

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
